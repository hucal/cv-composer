// Generated by CoffeeScript 1.9.2
var PI, add_to, array_from_vec3, camera, camera_far, canvas_line, container, controls, ctx_color, ctx_coords, extend, i, j, k, l, len, len1, len2, m, make_line, make_p_line, make_p_point, make_plane, make_point, max, obj, r2, r2_canvas, r2_resolution, r2_stage, r2_texture, r3_points, ref, ref1, render, renderer, root_objects, s2, s2_points, scene, theta, vec2, vec2_from_array, vec3, vec3_from_array;

if (!Detector.webgl) {
  Detector.addGetWebGLMessage;
}

container = document.getElementById('vis');

scene = new THREE.Scene;

scene.fog = new THREE.FogExp2(0xffffff, 0.002);

camera_far = 10000;

camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, camera_far);

renderer = new THREE.WebGLRenderer({
  antialias: true
});

renderer.setSize(container.offsetWidth, container.offsetHeight);

renderer.setClearColor(scene.fog.color, 1);

renderer.setPixelRatio(window.devicePixelRatio);

container.appendChild(renderer.domElement);

window.addEventListener('resize', function() {
  camera.aspect = container.offsetWidth / container.offsetHeight;
  camera.updateProjectionMatrix();
  return renderer.setSize(container.offsetWidth, container.offsetHeight);
});

r2_canvas = document.createElement('canvas');

r2_resolution = 1024;

r2_canvas.width = r2_canvas.height = r2_resolution;

r2_stage = new createjs.Stage(r2_canvas);

ctx_coords = function(xy, f) {
  var ref, x, y;
  ref = xy instanceof THREE.Vector3 || xy instanceof THREE.Vector2 ? [xy.x, xy.y] : xy, x = ref[0], y = ref[1];
  return f(r2_resolution / 2 * (x + 1), r2_resolution / 2 * (1 - y));
};

ctx_color = function(c) {
  if (c instanceof String || typeof c === "string") {
    return c;
  } else {
    return '#' + c.toString(16);
  }
};

canvas_line = function(p1, p2, color, width) {
  var c;
  c = ctx_coords(p1, function(x, y) {
    return r2_stage.addChild(new createjs.Shape()).set({
      x: x,
      y: y
    });
  });
  ctx_coords(p1, function(x1, y1) {
    return ctx_coords(p2, function(x2, y2) {
      return c.graphics.beginStroke(ctx_color(color)).setStrokeStyle(width).moveTo(0, 0).lineTo(x2 - x1, y2 - y1);
    });
  });
  return c;
};

PI = Math.PI;

vec2 = function(x, y) {
  return new THREE.Vector2(x, y);
};

vec3 = function(x, y, z) {
  return new THREE.Vector3(x, y, z);
};

array_from_vec3 = function(v) {
  return (v instanceof THREE.Vector3 ? [v.x, v.y, v.z] : v);
};

vec3_from_array = function(p) {
  return (p instanceof THREE.Vector3 ? p : vec3(p[0], p[1], p.length > 2 ? p[2] : 1));
};

vec2_from_array = function(p) {
  return (p instanceof THREE.Vector2 ? p : vec2(p[0], p[1]));
};

add_to = function(c, o) {
  c.push(o);
  return o;
};

s2_points = [];

r3_points = [];

root_objects = [];

extend = function(v1, v2, length) {
  var v1_orig;
  if (length == null) {
    length = camera_far;
  }
  v1_orig = v1.clone();
  v1.sub(v2);
  v1.setLength(length);
  v1.add(v2);
  v2.sub(v1_orig);
  v2.setLength(length);
  v2.add(v1_orig);
  return [v1, v2];
};

make_point = function(collection, size, color, opacity, detail) {
  if (opacity == null) {
    opacity = 1.0;
  }
  if (detail == null) {
    detail = 15;
  }
  return add_to(collection, new THREE.Mesh(new THREE.SphereGeometry(size, detail, detail), new THREE.MeshLambertMaterial({
    color: color,
    transparent: opacity !== 1.0,
    opacity: opacity
  })));
};

make_plane = function(collection, size, color, opacity) {
  if (opacity == null) {
    opacity = 1.0;
  }
  return add_to(collection, new THREE.Mesh(new THREE.PlaneGeometry(size, size), new THREE.MeshBasicMaterial({
    color: color,
    side: THREE.DoubleSide,
    transparent: opacity !== 1.0,
    opacity: opacity
  })));
};

make_line = function(collection, here, there, color, width, extend_vectors) {
  var geometry, ref, v1, v2;
  if (width == null) {
    width = 1;
  }
  if (extend_vectors == null) {
    extend_vectors = true;
  }
  v1 = vec3_from_array(here);
  v2 = vec3_from_array(there);
  if (extend_vectors) {
    ref = extend(v1, v2), v1 = ref[0], v2 = ref[1];
  }
  geometry = new THREE.Geometry;
  geometry.vertices.push(v1, v2);
  return add_to(collection, new THREE.Line(geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  })));
};

make_p_point = function(p, color) {
  var c, o1, o2, o3;
  p = vec2_from_array(p);
  c = ctx_coords(p, function(x, y) {
    return r2_stage.addChild(new createjs.Shape()).set({
      x: x,
      y: y
    });
  });
  c.graphics.beginFill(ctx_color(color)).drawCircle(0, 0, 4);
  o1 = make_line(r3_points, [-p.x, -p.y, -1], [p.x, p.y, 1], color);
  o2 = make_point(s2_points, 0.0075, color);
  o2.position.copy(vec3(p.x, p.y, 1).normalize());
  o3 = make_point(s2_points, 0.0075, color);
  o3.position.copy(vec3(-p.x, -p.y, -1).normalize());
  return {
    r2: [c],
    s2: [o2, o3],
    r3: [o1]
  };
};

make_p_line = function(p1, p2, color, opacity, draw_points) {
  var _p1, _p2, angle, c, o, ref, v1, v2;
  if (opacity == null) {
    opacity = 1.0;
  }
  if (draw_points == null) {
    draw_points = false;
  }
  ref = [vec2_from_array(p1), vec2_from_array(p2)], p1 = ref[0], p2 = ref[1];
  c = canvas_line(p1, p2, color, 3);
  _p1 = _p2 = [];
  if (draw_points) {
    _p1 = make_p_point(p1, color);
    _p2 = make_p_point(p2, color);
  }
  o = make_plane(r3_points, 3, color, opacity);
  v1 = vec3(p1.x, p1.y, 1);
  v2 = vec3(p2.x, p2.y, 1);
  v1.cross(v2);
  v1.normalize();
  angle = v1.angleTo(vec3(0, 0, 1));
  o.rotation.setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(vec3(0, 0, 1), v1));
  return {
    r2: _p1.r2.concat(_p2.r2).concat(c),
    s2: _p1.s2.concat(_p2.s2),
    r3: _p1.r3.concat(_p2.r3).concat([o])
  };
};

make_plane(root_objects, 2, 0xbbffbb);

s2 = make_point(s2_points, 1, 0xffffff, 0.2, 90);

r2_texture = new THREE.Texture(r2_canvas);

r2_texture.needsUpdate = true;

r2 = add_to(root_objects, new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({
  side: THREE.DoubleSide,
  map: r2_texture,
  transparent: true
})));

r2.position.z = 1;

max = 10;

for (i = j = ref = -max, ref1 = max; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
  canvas_line([i / max, 1], [i / max, -1], 0x222222, 1);
  canvas_line([1, i / max], [-1, i / max], 0x222222, 1);
}

scene.add(new THREE.AmbientLight(0x404040));

scene.add(new THREE.HemisphereLight(0xffffff, 0x404040, 1));

for (k = 0, len = root_objects.length; k < len; k++) {
  obj = root_objects[k];
  scene.add(obj);
}

make_p_point([0, 0], 0xff0000);

make_p_point([0.5, 0.5], 0xff0000);

make_p_line([0.2, 0.2], [-0.3, 0.4], 0xaa00ff, 1.0, true);

make_p_line([-0.2, -0.2], [0.3, -0.3], 0xff00aa, 1.0, true);

for (l = 0, len1 = s2_points.length; l < len1; l++) {
  obj = s2_points[l];
  scene.add(obj);
}

for (m = 0, len2 = r3_points.length; m < len2; m++) {
  obj = r3_points[m];
  scene.add(obj);
}

r2_stage.update();

camera.position.z = 2;

theta = -PI * 3 / 4;

camera.position.y = 3 * Math.sin(theta);

camera.position.x = 3 * Math.cos(theta);

controls = new THREE.OrbitControls(camera, renderer.domElement);

controls.enableDamping = true;

controls.dampingFactor = 0.1;

controls.enablePan = false;

render = function() {
  requestAnimationFrame(render);
  renderer.render(scene, camera);
  return controls.update();
};

render();

//# sourceMappingURL=vis.js.map
